# 发布与演示

***

<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [发布与演示](#发布与演示)
	- [n14p1 智能充电表演示程序](#n14p1-智能充电表演示程序)
	- [n14p2 思维控制器流程](#n14p2-思维控制器流程)
	- [n14p3 中层循环管理器](#n14p3-中层循环管理器)
	- [n14p4 loopManager](#n14p4-loopmanager)
	- [n14p5 loopModel](#n14p5-loopmodel)
	- [n14p6 决策与预测_循环 (收集信息阶段)](#n14p6-决策与预测循环-收集信息阶段)
	- [n14p7 决策与预测_循环 (抽象本质阶段)](#n14p7-决策与预测循环-抽象本质阶段)

<!-- /TOC -->


<br><br><br><br><br>



## n14p1 智能充电表演示程序
`CreateTime 2018.08.02`

| 简介 >> |
| --- |
| 1. smg可实现各种通用的智能应用,但新生儿不具备复杂的知识 |
| 2. 本节通过演示smg如何实现一个智能的钟表; |
| 3. 该钟表知道自己一天有三次充电,并且可以通过几天的学习,明确的表达出早餐,午餐,晚餐这样的充电需求; |

<br>

| 分析 >> |
| --- |
| 1. 该钟表有明确的电量mv,还有两个感官,分别为"字符串"和"时间" |



<br><br><br><br><br>



## n14p2 思维控制器流程
`CreateTime 2018.08.03`

| 思维控制器流程图 |
| --- |
| ![](assets/58_思维控制器流程图.png) |

<br>

| 两次截断 >> | 1 | 2 |
| --- | --- | --- |
| 思考截断时机 | ass之前 | decision时 |
| 截断频次 | 很少,只有专注时如此 | 很多,几乎所有 |
| 代码实践 | 暂不实现,相信代码并行 | 通过cmvCache和energy实现 |
| 工作描述 |  | `非特定思考`独立线运行 |
| 运行方式 |  | 被"无目的"激活后,loop,并实时更新cmvCache和energy |
| 代码详情 |  | loop只是整个ass的递归,(包括assExp和assData) |

<br>

| 思维控制器内_循环示图 >> |
| --- |
| ![](assets/59_循环.png) |




<br><br><br><br><br>



## n14p3 中层循环管理器
`CreateTime 2018.08.04`

| 简介 >> |
| --- |
| 1. 决策,并非仅是决策输出,包括思维活动,内心的一些需求,未必需要通过外界表达才可得到解决 |
| 2. 所以本节,主要通过对cmvCache的改版,(重命名为loopCache);的方式来尝试实践中层循环; |

<br>

| 思考 >> | 注 |
| --- | --- |
| 1. 思维无法作为决策者,而是网络; | 所以在死思维上,呈现活思维至关重要 |
| 2. 去重可直接以redis.exist()查询; | 但最好还是以独立模型的方式运作; |
| 3. 需要一个内存网络或模型,来把所有循环的数据合理记录 | 所以cmvCache更名为loopCache |
| 4. 决策是在不同的实现中作选择 | 所以需要一个实时序列的模型; |

<br>

| 流程 >> |
| --- |
| 1. inputMV |
| 2. havMv时,判断havDemand==true时,生成loopModel并加到loopManager.loopCache; |
| 3. noMv时,assData,如果联想到mv,并且根据当前"状态"判定havDemand=true,也加到loopCache |
| 4. loopManger根据实时序列,排出最靠前的loopModel并ass联想思考; |
| 5. 每次思考后,将相关数据附加到对应的loopModel,并递归到下次循环; |
| 6. 判断energy,并refreshOrder;再进入下一轮思考; |

<br>

| 模型 >> | 作用 | 说明 |
| --- | --- | --- |
| 1. 时间衰减 | 维持稳定性 | 懒衰减(refreshOrder前) |
| 2. 实时序列 | 使思维灵活 | refreshOrder |
| 3. 专注首条 | 仅能针对第一条loopModel作思考 |  |



<br><br><br><br><br>



## n14p4 loopManager
`CreateTime 2018.08.06`

| 及时性1:惊 >> |
| --- |
| 1. 当网络中既有信息产生预测,但并不相符时,产生惊 |
| 2. 惊只是为了让外界input及时获得注意力(loopCache之首);并让思维及时响应当下; |
| 3. 添加各种基础情绪,都能够让smg获得更加复杂智能的运行,但这并非核心,所以v1界不实现; |

<br>

| 及时性2:时间衰减 >> |
| --- |
| 1. 时间衰减具基础性,所以需优先实现 |

<br>

| 及时性3:实时序列 >> |
| --- |
| 1. 每一次loop前,先refreshLoopCache序列,再取首循环; |

<br>

| 持续性1:loopModel.order值叠加 >> |
| --- |
| 在loopModel中,order值,即是各种联想后,综合各路相关mv加出的值; |

<br>

| 持续性2:习惯 > |
| --- |
| 1. 习惯会作为网络级的长期加强,让长期的任务维持 |


<br><br><br><br><br>

## n14p5 loopModel
`CreateTime 2018.08.06`

| 简介 >> |
| --- |
| 1. 本节通过分析loopModel,来思考思维循环中,这次的重构到底如何进行? |

<br>

| 分析 >> |
| --- |
| 1. 人类并非最正确选择,甚至经常选错; |
| 2. 一个loopModel(demand)并非固定对应x个决策; |
| 3. 决策只是在回顾与预测; |
| 4. 决策再变化,demand不变; |
| 5. 人类在更高且长远的价值需求上,坚持与放弃 |

<br>

| 结果 >> |
| --- |
| 1. 决策是特别依赖网络(经验常识等),且灵活的; |
| 2. 决策与loopModel有明确的界线分隔; |

<br>

| 原则 >> |
| --- |
| 1. loopModel只能通过mv与net交互; |

<br>

| 代码 >> |
| --- |
| 1.  |


<br><br><br><br><br>

## n14p6 决策与预测_循环 (收集信息阶段)
`CreateTime 2018.08.07`

| 前言 >> |
| --- |
| 1. 注:每一次输出,只是决策与预测上的一环;并不意味着结束; |
| 2. 决策与loopManager的交互,(当决策开始执行时,demand即挂起) |

| 两种解决 >> |
| --- |
| 1. 现实解决是一触即发的;(直接销毁被解决的loopModel) |
| 2. 但预测解决只是`挂起状态`; |

<br>

| 挂起状态(废弃) >> |
| --- |
| 1. 决策输出预测解决时,loopModel进入挂起状态，(挂起一段时长) |
| 2. 再由信息变化，比对折射回状态变化。(input与预测进行比对) |
| 3. 如果以cmvNode来比对，那么需要加入时间考虑。 |
| 4. `挂起一段时长`内,不会有心急等情绪; |

<br>

| 时间管理 >> |
| --- |
| 1. 时间衰减 |
| 2. 空档期,执行其它任务(预测挂起时) |
| 3. 长期目标很难制定,但一旦制定就写在net中; (存疑)(注:长期目标规划,暂不考虑实现) |


<br><br><br><br><br>


## n14p7 决策与预测_循环 (抽象本质阶段)
`CreateTime 2018.08.07`

| 简介 >> |
| --- |
| 1. 本节重点思考,在决策与预测中,哪些是重要的,关乎智能内核的,并将其列出; |
| 2. 在mv到思维再到循环决策的过程,这部分,最难的点在于决策需要应对复杂的世界; |

<br>

| 思考 >> |  |
| --- | --- |
| Q1 | 以上哪些是本质核心的?与智能内核息息相关,不可或缺的? |
| A1 |  |

<br>

| 为了应对现实世界的复杂 >> |
| --- |
| 1. 决策阶段仅通过mv影响loopModel |
| 2. 目前同一loopModel同时仅支持一条决策,今后再加;(有一个平衡点,1-3条左右) |
| 3. 决策的执行需要稳定设计 |
| 4. 决策的稳定性体现在为检索限定了方向(索引) |
| 5. 没有挂起状态; |






<br><br><br><br><br><br><br><br><br><br><br>
